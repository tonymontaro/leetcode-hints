<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](https://github.com/openset/leetcode/tree/master/problems/add-and-search-word-data-structure-design "Add and Search Word - Data structure design")
　　　　　　　　　　　　　　　　
[Next >](https://github.com/openset/leetcode/tree/master/problems/house-robber-ii "House Robber II")

## [212. Word Search II (Hard)](https://leetcode.com/problems/word-search-ii "单词搜索 II")

<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>

<p>Each word must be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

<p>&nbsp;</p>

<p><strong>Example:</strong></p>

<pre>
<strong>Input:</strong> 
<b>board </b>= [
  [&#39;<span style="color:#d70">o</span>&#39;,&#39;<span style="color:#d70">a</span>&#39;,&#39;a&#39;,&#39;n&#39;],
  [&#39;e&#39;,&#39;<span style="color:#d30">t</span>&#39;,&#39;<span style="color:#d00">a</span>&#39;,&#39;<span style="color:#d00">e</span>&#39;],
  [&#39;i&#39;,&#39;<span style="color:#d70">h</span>&#39;,&#39;k&#39;,&#39;r&#39;],
  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]
]
<b>words</b> = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code>

<strong>Output:&nbsp;</strong><code>[&quot;eat&quot;,&quot;oath&quot;]</code>
</pre>

<p>&nbsp;</p>

<p><b>Note:</b></p>

<ol>
	<li>All inputs are consist of lowercase letters <code>a-z</code>.</li>
	<li>The values of&nbsp;<code>words</code> are distinct.</li>
</ol>

### Related Topics
  [[Trie](https://github.com/openset/leetcode/tree/master/tag/trie/README.md)]
  [[Backtracking](https://github.com/openset/leetcode/tree/master/tag/backtracking/README.md)]

### Similar Questions
  1. [Word Search](https://github.com/openset/leetcode/tree/master/problems/word-search) (Medium)
  1. [Unique Paths III](https://github.com/openset/leetcode/tree/master/problems/unique-paths-iii) (Hard)

### Hints
<details>
<summary>Hint 1</summary>
You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?
</details>

<details>
<summary>Hint 2</summary>
If the current candidate does not exist in all words&#39; prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)</a> first.
</details>
